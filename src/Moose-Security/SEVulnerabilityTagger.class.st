"
I am an abstract class to represent a tagger of vulnerability.

Each of my subclasses will be able to find one kind of vulnerable entities in a model and tag them with a specific tag.

It is possibile to tag all vulnerable entities of a model executing:

```st
SEAbstractVulnerabilityTagger tagAllVulnerabilitiesOf: aMooseModel
```

It is also possible to tag only one kind of vulnerable entites executing:

```st
SETransformerVulnerabilityTagger tagVulnerabilitiesOf: aMooseModel
```
"
Class {
	#name : #SEVulnerabilityTagger,
	#superclass : #Object,
	#instVars : [
		'model',
		'tagName',
		'queryBlock'
	],
	#category : #'Moose-Security'
}

{ #category : #tagging }
SEVulnerabilityTagger class >> tagAllVulnerabilitiesOf: aModel [

	self vulnerabilityTaggers do: [ :tagger | tagger applyOn: aModel ]
]

{ #category : #accessing }
SEVulnerabilityTagger class >> tagName [

	^ self subclassResponsibility
]

{ #category : #'instance creation' }
SEVulnerabilityTagger class >> tagResultOf: aBlock with: aTag [

	^ self new
		  queryBlock: aBlock;
		  tagName: aTag;
		  yourself
]

{ #category : #tagging }
SEVulnerabilityTagger class >> tagVulnerabilitiesOf: aModel [

	^ self new
		  model: aModel;
		  tagVulnerabilities
]

{ #category : #accessing }
SEVulnerabilityTagger class >> vulnerabilityTaggers [

	^ { (SEVulnerabilityTagger
		   tagResultOf: [ :model :tagger |
			   (tagger nonTestClassesOf: model) select: [ :class |
				   class directImplementedInterfaces anySatisfy: [ :interface |
					   interface name = #Serializable ] ] ]
		   with: #SerializableClass)
		 }
]

{ #category : #'instance creation' }
SEVulnerabilityTagger >> applyOn: aModel [

	| tag |
	tag := aModel allTags
		       detect: [ :t | t name = self tagName ]
		       ifNone: [ aModel createTagNamed: self tagName ].
	(self queryBlock cull: aModel cull: self) do: [ :e | e tagWith: tag ]
]

{ #category : #accessing }
SEVulnerabilityTagger >> classes [ 
	^ self model allModelClasses 
]

{ #category : #accessing }
SEVulnerabilityTagger >> classesOf: aModel [ 
	^ aModel allModelClasses 
]

{ #category : #tagging }
SEVulnerabilityTagger >> findEntitiesNamed: anEntityName andTagWith: aTagName [
	"This method will look for all the entities having 
		a name (anEntityName) and will tag them with aTagName"
	

		| tag |
	tag := self model allTags
		       detect: [ :t | t name = aTagName ]
		       ifNone: [ self model createTagNamed: aTagName ].
	self queryEntitiesToTag do: [ :e | e tagWith: tag ]
]

{ #category : #accessing }
SEVulnerabilityTagger >> model [

	^ model
]

{ #category : #accessing }
SEVulnerabilityTagger >> model: anObject [

	model := anObject
]

{ #category : #accessing }
SEVulnerabilityTagger >> nonTestClasses [

	^ self classes reject: #isTestCase
]

{ #category : #accessing }
SEVulnerabilityTagger >> nonTestClassesOf: aModel [

	^ (self classesOf: aModel) reject: #isTestCase
]

{ #category : #accessing }
SEVulnerabilityTagger >> queryBlock [

	^ queryBlock
]

{ #category : #accessing }
SEVulnerabilityTagger >> queryBlock: anObject [

	queryBlock := anObject
]

{ #category : #accessing }
SEVulnerabilityTagger >> queryEntitiesToTag [

	^ self subclassResponsibility
]

{ #category : #accessing }
SEVulnerabilityTagger >> tagName [

	^ tagName
]

{ #category : #accessing }
SEVulnerabilityTagger >> tagName: anObject [

	tagName := anObject
]

{ #category : #tagging }
SEVulnerabilityTagger >> tagVulnerabilities [

	| tag |
	tag := self model allTags
		       detect: [ :t | t name = self tagName ]
		       ifNone: [ self model createTagNamed: self tagName ].
	self queryEntitiesToTag do: [ :e | e tagWith: tag ]
]
