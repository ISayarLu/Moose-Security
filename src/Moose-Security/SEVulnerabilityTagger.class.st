"
I am an abstract class to represent a tagger of vulnerability.

I should be configured with a block to find the entities to tag in a model and also configured with a tag name to tag those entities. I can then be applied on a model using `#applyOn:`.

It is possibile to tag all vulnerable entities of a model executing:

```st
SEVulnerabilityTagger tagAllVulnerabilitiesOf: aMooseModel
```

You can visualize the result of the tagging directly using:

```st
SEVulnerabilityTagger tagAndVisualize: aModel
```

You can remove all generated tags using:

```st
SEVulnerabilityTagger removeAllGeneratedTagsOf: aModel
```

It is also possible to tag only one kind of vulnerable entites executing:

```st
SEVulnerabilityTagger transformerClassTagger applyOn: aMooseModel
```
"
Class {
	#name : #SEVulnerabilityTagger,
	#superclass : #Object,
	#instVars : [
		'queryBlock'
	],
	#category : #'Moose-Security'
}

{ #category : #accessing }
SEVulnerabilityTagger class >> removeAllGeneratedTagsOf: aModel [

	self allSubclasses
		collect: [ :class | class tagName ]
		thenDo: [ :tagName |
			aModel allTags
				detect: [ :tag | tag name = tagName ]
				ifFound: [ :tag | tag remove ] ]
]

{ #category : #tagging }
SEVulnerabilityTagger class >> tagAllVulnerabilitiesOf: aModel [

	self vulnerabilityTaggers do: [ :tagger | tagger applyOn: aModel ]
]

{ #category : #accessing }
SEVulnerabilityTagger class >> tagAndVisualize: aMooseModel [

	self tagAllVulnerabilitiesOf: aMooseModel.

	((aMooseModel allUsing: FamixTNamedEntity) reject: #isStub) miPropagate.

	MiArchitecturalMapBrowser open
]

{ #category : #accessing }
SEVulnerabilityTagger class >> tagName [

	self subclassResponsibility
]

{ #category : #'instance creation' }
SEVulnerabilityTagger class >> tagResultOf: aBlock [

	^ self new
		  queryBlock: aBlock;
		  yourself
]

{ #category : #accessing }
SEVulnerabilityTagger class >> vulnerabilityTaggers [

	^ ((self class withAllSubclasses flatCollect: #methods) select: [ :method | method pragmas anySatisfy: [ :pragma | pragma selector = #cautionTagger ] ])
		  collect: [ :method | method methodClass soleInstance perform: method selector ]
]

{ #category : #'instance creation' }
SEVulnerabilityTagger >> applyOn: aModel [

	(self queryBlock cull: aModel cull: self) ifNotEmpty: [ :entities |
		| tag |
		tag := aModel allTags
			       detect: [ :t | t name = self tagName ]
			       ifNone: [ aModel createTagNamed: self tagName ].
		entities do: [ :e | e tagWith: tag ] ]
]

{ #category : #accessing }
SEVulnerabilityTagger >> classesImplementing: aString in: aModel [

	^ (self nonTestClassesOf: aModel) select: [ :class |
		  class directImplementedInterfaces anySatisfy: [ :interface |
			  interface ifNil: [ false ] ifNotNil: [ interface name = aString ] ] ]
]

{ #category : #accessing }
SEVulnerabilityTagger >> classesOf: aModel [ 
	^ aModel allModelClasses 
]

{ #category : #accessing }
SEVulnerabilityTagger >> methodsNamed: aString in: aModel [

	^ aModel allModelMethods select: [ :method |
		  method name = aString ]
]

{ #category : #accessing }
SEVulnerabilityTagger >> nonTestClassesOf: aModel [

	^ (self classesOf: aModel) reject: #isTestCase
]

{ #category : #accessing }
SEVulnerabilityTagger >> queryBlock [

	^ queryBlock
]

{ #category : #accessing }
SEVulnerabilityTagger >> queryBlock: anObject [

	queryBlock := anObject
]

{ #category : #accessing }
SEVulnerabilityTagger >> tagName [

	^ self class tagName
]
